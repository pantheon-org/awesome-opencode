# NOTE: YAML linters may show warnings due to JavaScript template strings in the script block.
# These warnings are cosmetic and can be safely ignored - the workflow functions correctly in GitHub Actions.

name: Categorize and Document Tool

on:
  issues:
    types: [labeled]

permissions:
  issues: write
  contents: write
  pull-requests: write

jobs:
  categorize:
    runs-on: ubuntu-latest
    if: github.event.label.name == 'in-review'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Load categories, themes, and prompt
        id: load-data
        run: |
          CATEGORIES=$(cat categories.json | jq -c '.categories')
          echo "categories=$CATEGORIES" >> $GITHUB_OUTPUT

          # Format categories for prompt
          CATEGORIES_PROMPT=$(cat categories.json | jq -r '.categories[] | "   - \(.slug): \(.description)"')
          echo "categories_prompt<<EOF" >> $GITHUB_OUTPUT
          echo "$CATEGORIES_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Format themes for prompt
          THEMES_PROMPT=$(cat themes.json | jq -r '.themes[] | select(.status == "active") | "   - \(.id): \(.description)\n     Keywords: \(.keywords | join(", "))"')
          echo "themes_prompt<<EOF" >> $GITHUB_OUTPUT
          echo "$THEMES_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Load prompt template
          PROMPT_TEMPLATE=$(cat .github/prompts/categorize-tool.md)
          echo "prompt_template<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT_TEMPLATE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post OpenCode categorization request
        uses: actions/github-script@v7
        env:
          CATEGORIES_PROMPT: ${{ steps.load-data.outputs.categories_prompt }}
          THEMES_PROMPT: ${{ steps.load-data.outputs.themes_prompt }}
          PROMPT_TEMPLATE: ${{ steps.load-data.outputs.prompt_template }}
        with:
          script: |
            const body = context.payload.issue.body;
            const urlMatch = body.match(/https:\/\/github\.com\/[^\s\)]+/);

            if (!urlMatch) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚ùå **Error**: No GitHub repository URL found. Cannot proceed with categorization.`
              });
              return;
            }

            const repoUrl = urlMatch[0];
            const repoPath = repoUrl.replace('https://github.com/', '');
            const repoName = repoPath.split('/').pop();
            const categoriesPrompt = process.env.CATEGORIES_PROMPT;
            const themesPrompt = process.env.THEMES_PROMPT;
            const currentDate = new Date().toISOString().split('T')[0];

            // Load and populate the prompt template
            const promptTemplate = process.env.PROMPT_TEMPLATE;
            const commentBody = promptTemplate
              .replace(/\{\{REPO_URL\}\}/g, repoUrl)
              .replace(/\{\{CATEGORIES_PROMPT\}\}/g, categoriesPrompt)
              .replace(/\{\{THEMES_PROMPT\}\}/g, themesPrompt)
              .replace(/\{\{ISSUE_NUMBER\}\}/g, context.issue.number)
              .replace(/\{\{REPO_NAME\}\}/g, repoName)
              .replace(/\{\{CURRENT_DATE\}\}/g, currentDate);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
